package accessor

type data struct {
	Package string
	Name    string
	Files   string
}

type templates []*template

func (ts templates) toString() string {
	var template string
	for _, t := range ts {
		template = template + t.text
	}
	return template
}

var embeddingTemplates = templates{
	packageTpl,
	importTpl,
	fsTpl,
	initTpl,
	embeddingTpl,
}

type template struct {
	name string
	text string
}

var packageTpl = &template{
	name: "package",
	text: `// Code generated by go-embedding-accessor.
// DO NOT EDIT!
package {{ .Package }}
`}

var importTpl = &template{
	name: "import",
	text: `
import (
        "bytes"
        "embed"
        "flag"
        "fmt"
        "io"
        "io/fs"
        "os"
        "path/filepath"
        "strings"
)
`}

var fsTpl = &template{
	name: "fs",
	text: `
//go:embed {{ .Files }}
var {{ .Name }}FS embed.FS
`}

var initTpl = &template{
	name: "init",
	text: `
func init() {
        var path string
        var list bool
        var restore bool
        var restorePath string

        f := flag.NewFlagSet(os.Args[0], flag.ContinueOnError)

        f.StringVar(&path, "show-{{ .Name }}", "", "show specified {{ .Name }}")
        f.BoolVar(&list, "list-{{ .Name }}", false, "list {{ .Name }}")
        f.BoolVar(&restore, "restore-{{ .Name }}", false, "restore {{ .Name }}")
        f.StringVar(&restorePath, "restore-path", ".", "restore {{ .Name }} to specified path")

        buf := &bytes.Buffer{}
        f.SetOutput(buf)

        err := f.Parse(os.Args[1:])
        if err != nil {
                // Continue if flag not found
                if strings.Contains(err.Error(), "flag provided but not defined:") {
                        return
                }
                // Continue if flag is "h" or "help"
                if err == flag.ErrHelp {
                        fmt.Fprintln(os.Stderr, buf.String())
                        return
                }
                // Exit if flag has error
                fmt.Fprintln(os.Stderr, buf.String())
                os.Exit(2)
        }

        if list {
                newEmbedding().list()
                os.Exit(0)
        }

        if path != "" {
                err := newEmbedding().show(path)
                if err != nil {
                        fmt.Fprintln(os.Stderr, err)
                        os.Exit(1)
                }
                os.Exit(0)
        }

        if restore {
                newEmbedding().restore(restorePath)
                if err != nil {
                        fmt.Fprintln(os.Stderr, err)
                        os.Exit(1)
                }
                os.Exit(0)
        }
}
`}

var embeddingTpl = &template{
	name: "embedding",
	text: `
type embedding struct {
        writer io.Writer
}

func newEmbedding() *embedding {
        return &embedding{writer: os.Stdout}
}

func (e *embedding) list() error {
        return fs.WalkDir({{ .Name }}FS, ".", func(path string, d fs.DirEntry, err error) error {
                if path == "." || path == ".." {
                        return nil
                }
                if d.IsDir() {
                        return nil
                }
                e.write(path)
                return nil
        })
}

func (e *embedding) show(path string) error {
        code, err := fs.ReadFile({{ .Name }}FS, path)
        if err != nil {
                return err
        }
        e.write(string(code))
        return nil
}

func (e *embedding) restore(out string) error {
        return fs.WalkDir({{ .Name }}FS, ".", func(path string, d fs.DirEntry, err error) error {
                if path == "." || path == ".." {
                        return nil
                }
                if d.IsDir() {
                        return os.MkdirAll(filepath.Join(out, path), 0755)
                }

                code, err := fs.ReadFile({{ .Name }}FS, path)
                if err != nil {
                        return err
                }
                return os.WriteFile(filepath.Join(out, path), code, 0644)
        })
        return nil
}

func (e *embedding) write(s string) {
        fmt.Fprintln(e.writer, s)
}
`}
